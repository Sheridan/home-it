#!/sbin/nft -f

# Managed by ansible. Editing is useless
# Sheridan

{% set internal_interface = network|selectattr('ifname', 'match', 'internal_.*')|first %}
{% set internal_interfaces = network|selectattr('ifname', 'match', 'internal_.*')|list %}
{% set external_interfaces = network|selectattr('ifname', 'match', 'external_.*')|list %}
{% set external_interfaces_ipv4 = network|selectattr('ifname', 'match', 'external_(rt|kis).*')|list %}
{% set external_interfaces_ipv6 = network|selectattr('ifname', 'match', 'external_he.*')|list %}

flush ruleset

{# filter, inet -#}
table inet filter {

  chain netscan_drop {
    {# bad tcp -> avoid network scanning -#}
    tcp flags & (fin|syn) == (fin|syn) counter drop comment "drop netscan 0"
    tcp flags & (syn|rst) == (syn|rst) counter drop comment "drop netscan 1"
    tcp flags & (fin|syn|rst|psh|ack|urg) < (fin) counter drop comment "drop netscan 2"
    tcp flags & (fin|syn|rst|psh|ack|urg) == (fin|psh|urg) counter drop comment "drop netscan 3"
  }

  chain lo_rules {
    {{ query('nft', 'as_iif', internal_interface) }} ip daddr 127.0.0.1/8 counter accept comment "Accept v4 to lo from internal"
    {{ query('nft', 'as_iif', internal_interface) }} ip6 daddr ::1/128 counter accept comment "Accept v6 to lo from internal"
    iif != lo ip daddr 127.0.0.1/8 counter log prefix "drop to loopback not from loopback: "
    iif != lo ip daddr 127.0.0.1/8 counter drop comment "drop connections to loopback not coming from loopback"
    iif != lo ip6 daddr ::1/128 counter log prefix "drop to loopback not from loopback: "
    iif != lo ip6 daddr ::1/128 counter drop comment "drop connections to loopback not coming from loopback6"
    oif lo counter accept comment "accept to loopback"
    iif lo counter accept comment "accept from loopback"
  }

  chain icmp_rules {
    ip protocol icmp limit rate 32/second counter accept comment "accept icmp"
    ip protocol icmp counter drop comment "drop burst icmp"
    ip6 nexthdr icmpv6 limit rate 32/second counter accept comment "accept icmp6"
    ip6 nexthdr icmpv6 counter drop comment "drop burst icmp6"
  }

  chain ipv6_spetial {
    {{ query('nft', 'as_iif', internal_interface) }} ip6 saddr { fe80::/16 } counter accept comment "accept from link-local"
    {{ query('nft', 'as_oif', internal_interface) }} ip6 daddr { fe80::/16 } counter accept comment "accept to link-local"
    {{ query('nft', 'as_iif', internal_interface) }} ip6 saddr { ff02::/16 } counter accept comment "accept from spetial"
    {{ query('nft', 'as_oif', internal_interface) }} ip6 daddr { ff02::/16 } counter accept comment "accept to spetial"
  }

  chain global {
    ct state {established, related} counter accept comment "accept all connections related to connections made by us"
    ct state invalid counter drop comment "drop invalid packets"
    jump icmp_rules
    jump lo_rules
    jump netscan_drop
    jump ipv6_spetial
  }

  {# output per host -#}
  {% for host_name in query('inventory_hostnames', 'all')|difference(['gate'])|sort -%}
  chain host_{{ host_name | replace('-','_') }} {
    {# -#}
    {%- set host = hostvars[host_name].merged_vars -%}
    {%- if 'firewall' in host -%}
      {%- for host_internal_interface in host.network -%}
        {%- for rule_name in host.firewall.host_to_internet -%}
          {%- set rule = host.firewall.host_to_internet[rule_name] -%}
          {%- for protocol in ['tcp', 'udp'] -%}
            {%- for ip_version in ['ipv6', 'ipv4'] -%}
              {%- set nfipv = 'ip' if ip_version == 'ipv4' else 'ip6' -%}
    {{ query('nft', 'as_iif', internal_interface) }} {{ nfipv }} saddr {{ host_internal_interface.ip[ip_version].ip }} {% if 'ports' in rule -%} {{ protocol }} dport {{ query('nft', 'list_or_single', rule.ports) }} {%- endif %} counter goto to_provider_{{ ip_version }} comment "[{{ host_name }}->internet] {{ rule.name }} [{{ protocol }}]"
    {# -#}
            {%- endfor -%}
          {%- endfor -%}
        {%- endfor -%}
      {%- endfor -%}
    {%- endif -%}
  }

  {# -#}
  {%- endfor -%}

  chain network_hosts {
    {% for host_name in query('inventory_hostnames', 'all')|difference(['gate'])|sort -%}
    jump host_{{ host_name | replace('-','_') }}
    {# -#}
    {%- endfor -%}
  }

  chain to_provider_ipv4 {
    {% for external_interface in external_interfaces_ipv4 -%}
    {{ query('nft', 'as_oif', external_interface) }} counter accept comment "Accepted to {{ external_interface.ifname }} ({{ external_interface.name }})"
    {# -#}
    {%- endfor -%}

  }

  chain to_provider_ipv6 {
    {% for external_interface in external_interfaces_ipv6 -%}
    {{ query('nft', 'as_oif', external_interface) }} counter accept comment "Accepted to {{ external_interface.ifname }} ({{ external_interface.name }})"
    {# -#}
    {%- endfor -%}

  }

  chain onion_to_tor {
    {{ query('nft', 'as_iif', internal_interface) }} ip daddr {{ merged_vars.tor.network.ipv4.net }}/{{ merged_vars.tor.network.ipv4.mask }} counter accept comment "[network->tor] Accepted to Tor"
  }

  chain to_self {
    {# to_host -#}
    {% for rule_name in merged_vars.firewall.to_host|list -%}
      {%- set rule = merged_vars.firewall.to_host[rule_name] -%}
      {%- for protocol in ['tcp', 'udp'] -%}
        {%- for rule_interface_name_part in rule.interfaces -%}
          {%- for rule_interface in network|selectattr('ifname', 'match', '.*' + rule_interface_name_part + '.*')|list -%}
            {%- if 'max_rate' in rule -%}
    {{ query('nft', 'as_iif', rule_interface) }} {{ protocol }} {% if 'ports' in rule -%} dport {{ query('nft', 'list_or_single', rule.ports) }} {%- endif %} limit rate {{ rule.max_rate.count }}/{{ rule.max_rate.per_period }} burst {{ rule.max_rate.burst }} packets counter accept comment "[->{{ inventory_hostname }}] {{ rule.name }} [{{ protocol }}]"
    {{ query('nft', 'as_iif', rule_interface) }} {{ protocol }} {% if 'ports' in rule -%} dport {{ query('nft', 'list_or_single', rule.ports) }} {%- endif %} limit rate 8/second log prefix "Input {{ rule.name }} [{{ protocol }}] limit: "
    {{ query('nft', 'as_iif', rule_interface) }} {{ protocol }} {% if 'ports' in rule -%} dport {{ query('nft', 'list_or_single', rule.ports) }} {%- endif %} counter drop comment "[->{{ inventory_hostname }}] {{ rule.name }} [{{ protocol }}]"
    {# -#}
            {%- else -%}
    {{ query('nft', 'as_iif', rule_interface) }} {{ protocol }} {% if 'ports' in rule -%} dport {{ query('nft', 'list_or_single', rule.ports) }} {%- endif %} counter accept comment "[->{{ inventory_hostname }}] {{ rule.name }} [{{ protocol }}]"
    {# -#}
            {%- endif -%}
          {%- endfor -%}
        {%- endfor -%}
      {%- endfor -%}
    {%- endfor -%}
  }

  chain output {
    type filter hook output priority 0; policy accept;
    jump global
    counter comment "output accepted packets"
  }

  chain forward {
    type filter hook forward priority 0; policy drop;
    jump global
    jump network_hosts
    jump onion_to_tor
    limit rate 8/second log prefix "Forward dropped: "
    counter comment "forward dropped packets"
  }

  chain input {
    type filter hook input priority 0; policy drop;
    jump global
    jump to_self
    limit rate 8/second log prefix "Input dropped: "
    counter comment "input dropped packets"
  }

}

{# nat, ipv4 -#}
table ip nat {

  chain onion_to_tor {
    {% for protocol in ['tcp', 'udp'] -%}
    ip daddr {{ merged_vars.tor.network.ipv4.net }}/{{ merged_vars.tor.network.ipv4.mask }} ip protocol {{ protocol }} counter dnat to 127.0.0.1:{{ merged_vars.tor.ports.transparent }} comment "[home->tor] ipv4 DNAT {{ protocol }}"
    {# -#}
    {%- endfor -%}
  }

  chain prerouting {
    type nat hook prerouting priority 0; policy accept;
    jump onion_to_tor
    counter comment "count accepted packets"
  }

  chain input {
    type nat hook input priority 0; policy accept;
    counter comment "count accepted packets"
  }

  chain output {
    type nat hook output priority 0; policy accept;
    counter comment "count accepted packets"
  }

  chain postrouting {
    type nat hook postrouting priority 100; policy accept;

    {% for prov in ['kis', 'rt'] -%}
      {% set host = hostvars['probe-' + prov].merged_vars -%}
      {%- for host_internal_interface in host.network -%}
    ip saddr {{ host_internal_interface.ip.ipv4.ip }} {{ query('nft', 'as_oif', network|selectattr('ifname', 'match', 'external_' + prov + '.*')|first) }} counter masquerade comment "probe-{{ prov }} masquerade"
    {# -#}
      {%- endfor -%}
    {%- endfor -%}

    {% for external_interface in external_interfaces -%}
      {%- if 'ipv4' in external_interface.ip -%}
    ip saddr {{ networks.home.subnet.ipv4.full }} {{ query('nft', 'as_oif', external_interface) }} counter masquerade comment "Network masquerade through {{ external_interface.ifname }} ({{ external_interface.name }})"
    {# -#}
      {%- endif -%}
    {%- endfor -%}

    counter comment "count accepted packets"
  }
}

{# nat, ipv6 -#}
table ip6 nat {

  chain onion_to_tor {
    {% for protocol in ['tcp', 'udp'] -%}
    ip6 daddr {{ merged_vars.tor.network.ipv6.net }}/{{ merged_vars.tor.network.ipv6.mask }} ip6 nexthdr {{ protocol }} counter dnat to [::1]:{{ merged_vars.tor.ports.transparent }} comment "[home->tor] ipv6 DNAT {{ protocol }}"
    {# -#}
    {%- endfor -%}
  }

  chain prerouting {
    type nat hook prerouting priority 0; policy accept;
    jump onion_to_tor
    counter comment "count accepted packets"
  }

  chain input {
    type nat hook input priority 0; policy accept;
    counter comment "count accepted packets"
  }

  chain output {
    type nat hook output priority 0; policy accept;
    counter comment "count accepted packets"
  }

  chain postrouting {
    type nat hook postrouting priority 100; policy accept;
    counter comment "count accepted packets"
  }
}
